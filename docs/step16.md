## Saga Pattern?
> 마이크로 서비스에서 데이터 일관성을 관리하는 방법이다.     
> 각 서비스는 로컬 트랜잭션을 수행하고, 서비스가 완료된 후 이벤트 또는 메시지를 발행하여 다음 서비스로 작업을 전달한다.     
> 프로세스가 실패할 경우, 보상 트랜잭션을 통해 이전 단계의 작업을 롤백하여 데이터 일관성을 보장한다.  
> Saga 패턴은 분산 시스템에서 트랜잭션을 처리하는데 유용하며, NoSQL 같은 분산 DB에서 트랜잭션 처리를 지원하지 않거나  
> 다른 DB 벤더를 사용하는 환경에서도 데이터 일관성을 유지할 수 있다.

## Choreography 방식?
> 서비스간에 직접적으로 통신하지 않고, 이벤트 Pub/Sub을 활용해서 통신하는 방식이다.  
> 프로세스를 진행하다가 여러 서비스를 거쳐 서비스에서 실패가 난다면 보상 트랜잭션 이벤트 발행한다.   
> 장점: 간단한 workflow에 적합하며 새로운 서비스의 추가나 유지 관리가 간단하다.   
> 단점: 모든 서비스가 통합적으로 실행되어야 하므로 통합테스트나 디버깅이 어렵다.

## 내가 개발한 서비스 트랜잭션 범위
> 현재 시스템에서 트랜잭션의 범위는 ConcertPaymentUseCase 내에서 결제 및 예약 상태 변경,   
> 포인트 차감, 대기열 만료 기능을 하나의 트랜잭션으로 묶어서 처리하고 있다.

### 주요 처리과정
- 결제 정보를 생성 및 저장.
- 예약상태를 설정 및 예약을 완료.
- 포인트를 차감
- 대기열을 만료처리
모든 작업은 하나의 트랜잭션 내에서 이루어지며, 오류 발생시 전체 롤백이 된다.

## 서비스 규모 확장시의 문제점
> 서비스의 규모가 확장되면, 각 기능을 독립적인 서비스로 분리 할 필요성이 커진다.    
> 예를들어 결제, 예약상태 변경, 포인트 차감, 대기열 만료 기능를    
> 각 독립적으로 운영하는 방식으로 서비스를 분리하여 결합도를 줄일수 있다.  

### 서비스 분리에 따른 트랜잭션 처리의 한계
> 서비스가 분리되면 각 서비스가 개별적인 트랜잭션 범위를 가지게 되며, 분산된 트랜잭션 처리가 생긴다.  
> 예를 들면, 결제가 성공했지만 포인트 차감에 실패하는 상황 발생할수 있다.  
> 이런 경우 일관성 보장을 할 수 없다.

## 트랜잭션 처리의 한계 해결 방항
서비스를 분리하면서도 트랜잭션의 일관성을 유지하기 위해 Saga 패턴을 사용하여 분산 트랜잭션을 관리 할수 있다!  
Saga 패턴은 각 서비스를 업데이트 하고 메시지 또는 이벤트를 게시하여 다음 트랜잭션 단계를 트리거하는 일련의 트랜잭션이다.  
단계가 실패하면 Saga는 이전 트랜잭션을 상쇄하는 보상 트랜잭션을 실행하여 일관성을 보장한다.

### Choreography 기반 Saga 패턴
각 서비스가 독립적으로 이벤트를 발행하고 다른 서비스가 이를 구독하여 필요한 작업을 수행하는 방식

### 프로세스 흐름
1. 결제 진행 후 예약 상태 변경 이벤트 발행
> 결제가 완료되면, 예약 상태 변경 이벤트를 발행하여 예약 상태를 변경합니다.
2. 예약 상태 변경 후 포인트 차감 이벤트 발행 
> 예약 상태가 변경되면, 포인트 차감 이벤트가 발행됩니다.
3. 포인트 차감 후 대기열 만료 이벤트 발행
> 포인트 차감이 완료되면, 대기열 만료 이벤트가 발행됩니다.
4. 대기열 만료 후 결제 완료 알림
> 대기열이 만료되면, 사용자에게 결제 완료 알림을 발송합니다.

### 보상 트랜잭션 처리
각 단계에서 실패할 경우, 보상 트랜잭션을 통해 이전에 성공한 단계를 롤백해야 한다.  
예를 들어, 포인트 차감후 대기열 만료가 실패하면 이미 차감된 포인트를 되돌려야 한다. 

1. 결제 실패 시: 결제가 실패하면 이미 변경된 예약 상태를 롤백하거나 취소하는 보상 트랜잭션을 발행.
2. 예약 상태 변경 실패 시: 예약 상태가 변경되지 않으면 결제 상태를 취소하는 보상 트랜잭션을 발행.
3. 포인트 차감 실패 시: 차감된 포인트를 되돌리기 위해 포인트 복구 이벤트를 발행.
4. 대기열 만료 실패 시: 대기열 만료가 실패하면 결제 및 예약 상태를 원래대로 되돌리는 보상 트랜잭션을 발행.

> 보상 트랜잭션을 적절하게 구현해야 서비스가 분리 되었더라도 시스템의 일관성을 유지할 수 있다.
