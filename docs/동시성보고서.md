# 시나리오에서 발생할 수 있는 동시성 이슈
## 비관적 락
  ### 특징: 다른 트랜잭션이 해당 데이터에 접근하려고 하면 기다리게 한다.   
  ### 장점: 데이터 충돌을 방지하여 트랜잭션이 실패할 위험이 적고 데이터의 일관성을 보장한다.  
  ### 단점: 경쟁이 치열한 경우 성능이 저하되고 대기 시간이 길어진다.  
## 낙관적 락
  ### 특징: 버전 관리로 충돌 여부를 체크한다.  
  ### 장점: 데이터 접근에 대한 제한이 없고 동시에 많은 사용자들이 동시에 접근한다.  
  ### 단점: 트랜잭션 충돌이 발생하면 롤백되고 재시도도 가능하지만 충돌이 빈번할 경우 성능이 저하된다.

## 1. 좌석 선점(예약)
> 최대 50명의 사용자가 동시에 동일한 좌석에 예약할 경우 발생. 

## 락 적용 방식
### 낙관적 락
> @Version 필드를 통해 버전 번호를 관리하고
> findByConcertIdAndConcertScheduleIdAndConcertSeatIdIn 메서드에 @Lock(LockModeType.OPTIMISTIC)을 적용하여,
> 좌석 정보를 조회할 때 낙관적 락을 사용하도록 했습니다. 그 결과 동일 좌석에 대해 동시에 예약을 시도 할때 한 사용자가 먼저 업데이트를 완료하면 
> 다른 사용자의 트랜잭션은 OptimisticLockException을 발생 시킵니다. 추가적으로 해당 시나리오에는 재시도가 필요하지 않아보여
> 구현하지 않습니다.

### 비관적 락
> findByConcertIdAndConcertScheduleIdAndConcertSeatIdIn 메서드에 @Lock(LockModeType.PESSIMISTIC_WRITE)를 적용하여, 
> 좌석 정보를 조회할 때 비관적 락이 적용되도록 변경합니다. 
> 그 결과 데이터를 조회 및 수정하는 동안 다른 트랜잭션이 해당 데이터에 접근하려고 하면 대기하게 됩니다.

## 수행 시간 (총 실행 횟수: 10)
### 낙관적 락 (50명)
> 전체 평균 소요 시간: 461ms  
> 최소 소요 시간: 155ms  
> 최대 소요 시간: 162ms  
> 평균 소요 시간: 158ms  
### 낙관적 락 (1000명)
> 전체 평균 소요 시간: 1sec288ms  
> 최소 소요 시간: 980ms  
> 최대 소요 시간: 1018ms  
> 평균 소요 시간: 996ms
### 비관적 락 (50명)
> 전체 평균 소요 시간: 542ms  
> 최소 소요 시간: 171ms               
> 최대 소요 시간: 231ms  
> 평균 소요 시간: 194ms  
### 비관적 락 (1000명)
> 전체 평균 소요 시간: 1sec481ms  
> 최소 소요 시간: 1094ms  
> 최대 소요 시간: 1280ms  
> 평균 소요 시간: 1113ms  

##결론 
> 좌석 선점 시나리오에서는 많은 사용자가 동시에 접근할 가능성이 높아 낙관적 락을 사용하는게 적합하다고 생각합니다.  
> 특히 좌석 선점과 같이 재시도가 필요없는 상황에서는 더 효율적이락 생각됩니다.  
> 대기시간 없이 접근하여 빠른 시간내에 많은 사용자가 좌석을 예약할 수 있을 거 같습니다.  
> 비관적 락은 트랜잭션이 길어질수록 대기 시간이 증가해 사용자에게 불편함을 초래할거 같습니다.  
> 그래서 좌석 선점과 같이 다수가 동시에 접근하되 빠른 응답성이 필요한 경우에는 낙관적 락을 사용하는 것이 좋아보입니다.  

## 2. 잔액 충전
> 동일한 사용자가 동시에 5번 충전했을 때 5번 다 충전이 되어야한다.

### 락 적용 방식
### 낙관적 락
> @Version 필드르 통해 버전 번호를 관리하고 findByUserId 메서드에 @Lock(LockModeType.OPTIMISTIC) 적용했습니다.  
> 해당 시나리오에는 retry이가 필요해서 리트라이 횟수를 1000번으로 설정해 구현했습니다. 리트라이 설정을 2번으로 했을 경우 실패하기도 했습니다.
> 
### 비관적 락
> findByUserId 메서드에 @Lock(LockModeType.PESSIMISTIC_WRITE) 적용하여, 잔액을 조회할때 비관적 락이 적용되도록 했습니다.

## 수행 시간 (총 실행 횟수: 5)
### 낙관적 락 (2번)
> 전체 평균 소요 시간: 564ms  
> 최소 소요 시간: 210ms  
> 최대 소요 시간: 240ms  
> 평균 소요 시간: 222ms
### 낙관적 락 (5번)
> 전체 평균 소요 시간: 778ms  
> 최소 소요 시간: 348ms  
> 최대 소요 시간: 565ms  
> 평균 소요 시간: 457ms
### 비관적 락 (2번)
> 전체 평균 소요 시간: 391ms  
> 최소 소요 시간: 76ms               
> 최대 소요 시간: 92ms  
> 평균 소요 시간: 85ms
### 비관적 락 (5번)
> 전체 평균 소요 시간: 425ms  
> 최소 소요 시간: 94ms  
> 최대 소요 시간: 129ms  
> 평균 소요 시간: 108ms

##결론
> 동일 사용자가 동시에 여러 번 잔액을 충전하는 시나리오에서 낙관적 락과 비관적 락의 성능을 비교한 결과   
> 비관적 락이 더 적합하다고 생각합니다. 낙관적 락은 재시도 횟수 설정에 따라 처리 성능이 크게 달라지며,  
> 재시도를 반복할수록 시간과 자원이 추가로 소모됩니다. 낙관적 락은 예상치 못한 여러 상황에서 재시도가 자주 발생할 경우 성능저하가 심할 거같고  
> 돈과 같이 중요한 데이터를 다룰 때에는 효율적이지 않는거 같습니다.
> 비관적 락은 초기 접근에서부터 충돌을 방지하기 때문에 재시도를 피할수 있어 성능이 안정적이라고 생각됩니다.
> 두 락의 성능과 자원 소모에 차이가 있어 데이터의 중요성과 충돌 가능성을 고려해 선택하는 것이 좋을거같습니다.
